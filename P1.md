# PL - Práctica 1

## Lenguaje asignado: BBAAD
El lenguaje asignado está basado en la sintaxis de **C**, con las palabras reservadas en **inglés**, donde se añade a la lista de variables elementales la estructura de datos **lista**, los subprogramas son **funciones** y se incluye la estructura de control **do-until**.

## Descripción formal de la sintaxis del lenguaje usando BNF

```
# Descripciones básicas

<letra> ::= a | b | ... | z | A | B | ... | Z
<digito> ::= 0 | 1 | 2 | ... | 9

<ID> ::= <letra><letras_o_digitos>
<letras_o_digitos> ::= <letra><letras_o_digitos>
                     | <digito><letras_o_digitos>
                     |

<caracter_ascii> ::= * Todos los caracteres de la tabla ASCII
<cadena> ::= <delimitadador_cadena><cadena_ascii><delimitador_cadena>
<delimitador_cadena> ::= "
<cadena_ascii> ::= <caracter_ascii><cadena_ascii>
                 |
# Tipos
<tipo_variable_simple> ::= int 
                         | float 
                         | char 
                         | bool
<tipo_variable_complejo> ::= list_of <tipo_variable_simple>
<tipo_variable> ::= <tipo_variable_simple> 
                  | <tipo_variable_complejo>
                  
# Programa principal
<programa> ::= <cabecera_programa> <bloque> 
<cabecera_programa> ::= main

# Bloque general
<bloque> ::= <inicio_de_bloque>
             <declar_de_variables_locales>
             <declar_de_subprogs>
             <sentencias>
             <fin_de_bloque>

<inicio_de_bloque> ::= {
<fin_de_bloque> ::= }

# Variables locales
<declar_de_variables_locales> ::= <marca_ini_declar_variables> 
                                  <variables_locales> 
                                  <marca_fin_declar_variables> 
                                |                  
<marca_ini_declar_variables> ::= local <inicio_de_bloque>
<marca_fin_declar_variables> ::= <fin_de_bloque>

<variables_locales> ::= <variables_locales> <cuerpo_declar_variables>
                      | <cuerpo_declar_variables>
                      
<cuerpo_declar_variables> ::= <tipo_variable> <lista_variables> ;

<lista_variables> ::= <ID> , <lista_variables> 
                    | <ID>
                            
# Subprogramas (funciones)
<declar_de_subprogs> ::= <declar_de_subprogs> <declar_subprog> |

<declar_subprog> ::= <cabecera_subprog> <bloque> 

<cabecera_subprog> ::= <tipo_variable> <ID> (<parametros>)
                     | <tipo_variable> <ID> ()

<llamada_funcion> ::= <ID> (<lista_expresiones>) 
                    | <ID> ()

<parametros> ::= <parametro>, <parametros> 
               | <parametro>

<parametro> ::= <tipo_variable> <ID>

# Sentencia return
<sentencia_return> ::= return <expresion> ;

# Sentencias
<sentencias> ::= <sentencias> <sentencia> 
               | <sentencia>
               |
<sentencia> ::= <bloque>
              | <expresion> ;
              | <sentencia_asignacion>
              | <sentencia_if>
              | <sentencia_while> 
              | <sentencia_entrada>
              | <sentencia_salida>
              | <sentencia_do_until>
              | <sentencia_return>

# Asignación
<sentencia_asignacion> ::= <ID> <op_asignacion> <expresion> ;
<op_asignacion> ::= =

# IF
<sentencia_if> ::= if ( <expresion> ) <sentencia>

# While
<sentencia_while> ::= while ( <expresion> ) <sentencia>

# Entrada
<sentencia_entrada> ::= <nomb_entrada> <lista_variables> ;
<nomb_entrada> ::=  cin
                    
# Salida
<sentencia_salida> ::= <nomb_salida> <lista_expresiones_o_cadena> ;
<nomb_salida> ::= cout
<lista_expresiones_o_cadena> ::= <lista_expresion_o_cadena> , <expresion_cadena>
                              | <expresion_cadena>
<expresion_cadena> ::= <expresion>
                     | <cadena>

# Do-Until
<sentencia_do_until> ::= do <sentencia> until ( <expresion> ) ;


# Expresión (devuelven un valor)
<expresion> ::= (<expresion>) 
              |  <op_unario> <expresion>
              |  <expresion> <op_binario> <expresion>
              # Operador ternario de listas
              |  <expresion> ++ <expresion> @ <expresion>
              |  <ID>
              |  <constante>
              |  <llamada_funcion>
              
# Op unario
<op_unario> ::= <<
              | >>
              | $
              | -
              | +
              | !
# Op binario
<op_binario> ::= +
               | - 
               | * 
               | /
               | @
               | --
               | %
               | **
               | >=
               | >
               | <
               | <=
               | ==
               | !=

# Constantes
<constante> ::= <entero>
              | <real>
              | <bool>
              | <caracter>
              | <lista>
               
<entero> ::= <digito><numero>
           | <digito>

<real> ::= <entero> . <entero>
         | . <entero>
         | <entero> .

<caracter> ::= <delimitador_caracter> <caracter_ascii> <delimitador_caracter>
<delimitador_caracter> ::= '

<bool> ::= true
         | false

<lista> ::= <lista_inicio> <lista_expresiones> <lista_fin>
          | <lista_inicio> <lista_fin> 
<lista_inicio> ::= [
<lista_fin>    ::= ]
<lista_expresiones> ::= <expresion> 
                      | <expresion> , <lista_expresiones>
```
 
## Tabla de tokens

Para hacerlo más legible se han incluido las comillas dobles `"` pero no se leen, solo se leen en `CADENA` y las comillas simples `'` en `CHAR`.

| Nombre del token | Expresión regular | Código del token | Atributos |
|------------------|-------------------------------------------------|------------------|---------------------------------------------------------|
| INIBLOQUE  | `"{"` | 257 | |
| FINBLOQUE  | `"}"` | 258 | |
| LOCAL      | `"local"` | 259 | |
| TIPOSIMPLE | `"int" \| "float" \| "char" \| "bool"` | 260 | 0: int 1: float 2: char 3: bool                         |
| ID         | `[a-z\|A-Z][a-z\|A-Z\|0-9\|_]*` | 261 | |
| PARIZQ     | `"("` | 262 | |
| PARDER     | `")"` | 263 | |
| PYC        | `";"` | 264 | |
| CIN        | `"cin"` | 265 | |
| COUT       | `"cout"` | 266 | |
| CADENA     | `\"[^\"]*\"` | 267 | |
| RETURN     | `"return"` | 268 | |
| OPBIN      | ` "*" \| "/" \| "%" \| "**" \| "==" \| "!=" \| "&&" \| "\|\|" \| "<" \| ">" \| "<=" \| ">=" \| "&" \| "\|" \| "^" ` | 269 | 0: * 1: / 2: % 3: ** 4: == 5: != 6: && 7: \\\\ 8: < 9: > 10: <= 11: >= 12: & 13: \| 14: ^ |
| OPUNARIO     | `"--" \| "!" \| "#" \| "<<" \| ">>" \| "$"` | 270 | 0: -- 1: ++ 2: ! 3: # 4: >> 5: << 6: $ |
| AT         | `"@"`   | 271 | |
| MASMAS     | `"++"`  | 272 | |
| BINYUN     | `"+" \| "-"` | 273 | 0: + 1: - |
| CONST      | `([0-9]+) \| ([0-9]*\.[0-9]*) \| "true" \| "false" \| \'[^\']\' ` | 274 | |
| ASIGN      | `"="` | 275 | |
| COMA       | `","` | 276 | |
| MAIN       | `"main"` | 277 | |
| DO         | `"do"` | 278 | |
| UNTIL      | `"until"` | 279 | |
| IFWHILE    | `"if" \| "while"` | 280 | 0: if 1: while |
| LISTA      | `"list_of"` | 281 | |
| CORIZQ     | `"["` | 282 | |
| CORDER     | `"]"` | 283 | |

## Referencias

- Explicación de la expresión regular `[ -~]`: [https://catonmat.net/my-favorite-regex](https://catonmat.net/my-favorite-regex).
- https://import.viva64.com/docx/terminology/Priority/image1.png
