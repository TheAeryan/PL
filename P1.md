# PL - Práctica 1

## Lenguaje asignado: BBAAD
El lenguaje asignado está basado en la sintaxis de **C**, con las palabras reservadas en **inglés**, donde se añade a la lista de variables elementales la estructura de datos **lista**, los subprogramas son **funciones** y se incluye la estructura de control **do-until**.

## Descripción formal de la sintaxis del lenguaje usando BNF

```
# Descripciones básicas

<letra> ::= a | b | ... | z | A | B | ... | Z
<digito> ::= 0 | 1 | 2 | ... | 9

<ID> ::= <letra><letras_o_digitos>
<letras_o_digitos> ::= <letra><letras_o_digitos>
                     | <digito><letras_o_digitos>
                     |

<caracter_ascii> ::= * Todos los caracteres de la tabla ASCII
<cadena> ::= <delimitadador_cadena><cadena_ascii><delimitador_cadena>
<delimitador_cadena> ::= "
<cadena_ascii> ::= <caracter_ascii><cadena_ascii>
                 |
# Tipos
<tipo_variable_simple> ::= int 
                         | float 
                         | char 
                         | bool
<tipo_variable_complejo> ::= list_of <tipo_variable_simple>
<tipo_variable> ::= <tipo_variable_simple> 
                  | <tipo_variable_complejo>
                  
# Programa principal
<programa> ::= <cabecera_programa> <bloque> 
<cabecera_programa> ::= main

# Bloque general
<bloque> ::= <inicio_de_bloque>
             <declar_de_variables_locales>
             <declar_de_subprogs>
             <sentencias>
             <fin_de_bloque>

<inicio_de_bloque> ::= {
<fin_de_bloque> ::= }

# Variables locales
<declar_de_variables_locales> ::= <marca_ini_declar_variables> 
                                  <variables_locales> 
                                  <marca_fin_declar_variables> 
                                |                  
<marca_ini_declar_variables> ::= local <inicio_de_bloque>
<marca_fin_declar_variables> ::= <fin_de_bloque>

<variables_locales> ::= <variables_locales> <cuerpo_declar_variables>
                      | <cuerpo_declar_variables>
                      
<cuerpo_declar_variables> ::= <tipo_variable> <lista_nombres_variables> ;

<lista_nombres_variables> ::= <ID> 
                            | <ID> , <lista_nombres_variables>
                            
# Subprogramas (funciones)
<declar_de_subprogs> ::= <declar_de_subprogs> <declar_subprog> |

<declar_subprog> ::= <cabecera_subprog> <bloque> 

<cabecera_subprog> ::= <tipo_variable> <ID> (<parametros>)
                     | <tipo_variable> <ID> ()

<llamada_funcion> ::= <ID> (<lista_expresiones>) 
                    | <ID> ()

<parametros> ::= <parametro>, <parametros> 
               | <parametro>

<parametro> ::= <tipo_variable> <ID>

# Sentencia return
<sentencia_return> ::= return <tipos_expresion> ;

# Sentencias
<sentencias> ::= <sentencias> <sentencia> 
               | <sentencia>
               |
<sentencia> ::= <bloque>
              | <sentencia_asignacion>
              | <sentencia_if>
              | <sentencia_while> 
              | <sentencia_entrada>
              | <sentencia_salida>
              | <sentencia_do_until>
              | <sentencia_lista>
              | <sentencia_return>

# Asignación
<sentencia_asignacion> ::= <ID> <op_asignacion> <tipos_expresion> ;
<tipos_expresion> ::= <expresion> | <expresion_lista>
<op_asignacion> ::= =

# IF
<sentencia_if> ::= if ( <expresion> ) <sentencia>

# While
<sentencia_while> ::= while ( <expresion> ) <sentencia>

# Entrada
<sentencia_entrada> ::= <nomb_entrada> <lista_variables> ;
<nomb_entrada> ::=  cin
<lista_variables> ::= <ID> , <lista_variables> 
                    | <ID>
                    
# Salida
<sentencia_salida> ::= <nomb_salida> <lista_expresiones_o_cadena> ;
<nomb_entrada> ::=  cout
<lista_expresiones_o_cadena> ::= <lista_expresion_o_cadena> , <expresion_cadena>
                              | <expresion_cadena>
<expresion_cadena> ::= <expresion>
                     | <cadena>

# Do-Until
<sentencia_do_until> ::= do <sentencia> until ( <expresion> ) ;


# Expresión (devuelven un valor)
<expresion> ::= (<expresion>) 
              |  <op_unario> <expresion>
              |  <expresion> <op_binario> <expresion>
              # Operador ternario de listas
              |  <expresion> ++ <expresion> @ <expresion>
              |  <ID>
              |  <constante>
              |  <llamada_funcion>
              
# Op unario
<op_unario> ::= NOT
              | <<
              | >>
              | $
              | -
              | +
              | !
# Op binario
<op_binario> ::= + 
               | - 
               | * 
               | /
               | @
               | --
               | %
               | **
               | >=
               | >
               | <
               | <=
               | ==
               | !=
               | AND
               | OR
               | XOR 

# Constantes
<constante> ::= <entero>
               | <real>
               | <bool>
               | <caracter>
               | <lista>
               | <ID>
               
<entero> ::= <signo> <numero>
           | <numero>
           
<signo> ::= -
          | +
          
<numero> ::= <digito> <numero> 
           | <digito>

<real> ::= <entero> <decimal>
         | <decimal>
         | <entero> .

<decimal> ::= . <numero>

<caracter> ::= <delimitador_caracter> <caracter_ascii> <delimitador_caracter>
<delimitador_caracter> ::= '

<bool> ::= true
         | false

<lista> ::= <lista_inicio> <lista_expresiones> <lista_fin>
<lista_inicio> ::= [
<lista_fin>    ::= ]
```

## Tabla de Tokens

| Token         | id | Atributos                        | Patrón     |
|---------------|----|----------------------------------|------------|
| INIBLOQUE     | 0  | | "{" |
| FINBLOQUE     | 1  | | "}" |
| LOCAL         | 2  | | "local" |
| TIPOSIMPLE    | 3  | 0: int 1: float 2: char 3: bool  | `"int"|"float"|"char"|"bool"` |
| ID            | 4  | | [a-z|A-Z][a-z|A-Z|0-9]* |
| PARIZQ        | 5  | | "(" |
| PARDER        | 6  | | ")" |
| PYC           | 7  | | ";" |
| CIN           | 8  | | "cin" |
| COUT          | 9  | | "cout" |
| CADENA        | 10 | | `[ -~]*` |
| RETURN        | 11 | | "return" |
| OPBITWISE     | 12 | 0: & 1: \| 2: ^ | `"&"|"|"|"^" ` |
| OPBINNOBOOL   | 13 | 0: + 1: - 2: * 3: / 5: % 6: ** 7: == 8: != 9: && 10: \|\| | `"+"|"-"|"*"|"/"|"%"\|"**"|"=="|"!="|"&&"|"||"` |
| OPUNARIO      | 14 | 0: -- 1: ++ 2: ! | `"++"|"--"|"!"`
| OPRELACIONAL  | 15 | 0: < 1: > 2: <= 3: >= | `"<"|">"|"<="|">="` |
| OPLISTA       | 16 | 0: @ 1: ** 2: #     | `"@"|"**"|"#"` |
| SENLIST       | 17 | 0: >> 1: << 2: $ | `">>"\|"<<"\|"$"` |
| ENTERO        | 18 | | ` (-|+)?[0-9]+ ` |
| REAL          | 19 | | ` ENTERO.[0-9]* ` |
| BOOLEAN       | 20 | 0: true 1: false | ` "true"|"false" ` |
| ASIGN         | 21 | | "=" |
| COMA          | 22 | | "," |
| MAIN          | 23 | | "main" |
| DO            | 24 | | "do" |
| UNTIL         | 25 | | "until" |
| WHILE         | 26 | | "while" |
| IF            | 27 | | "if" |
| LISTA         | 28 | | "list_of" |
 
## Referencias

- Explicación de la expresión regular `[ -~]`: [https://catonmat.net/my-favorite-regex](https://catonmat.net/my-favorite-regex).
- https://import.viva64.com/docx/terminology/Priority/image1.png
